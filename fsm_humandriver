import numpy as np
import fuzzy_functs as ff
import pandas as pd

# 定义文件路径

def load_csv_to_dict_by_id(file_path):
    # 加载CSV文件
    data = pd.read_csv(file_path)

    # 初始化按车辆ID组织的数据字典
    data_by_id = {}

    # 遍历DataFrame的每一行
    for index, row in data.iterrows():
        vehicle_id = row['id']

        # 如果ID在字典中尚未有记录，则初始化一个空列表
        if vehicle_id not in data_by_id:
            data_by_id[vehicle_id] = []

        # 向对应车辆ID的列表中添加这一行数据的字典
        data_by_id[vehicle_id].append({
            'frame': row['frame'],
            'x': row['x'],
            'y': row['y'],
            'speed': row['xVelocity'],
            'speed_lat': row['yVelocity'],
            'width': row['width'],
            'length': row['height']
        })

    return data_by_id

def transform_data_for_fsm(data_dict):
    # 初始化FSM模型所需数据格式的字典
    fsm_ready_data = {}

    # 遍历每个车辆的数据
    for vehicle_id, records in data_dict.items():
        # 对每辆车，按帧组织数据
        for record in records:
            frame = record['frame']
            if frame not in fsm_ready_data:
                fsm_ready_data[frame] = {}
            fsm_ready_data[frame][vehicle_id] = {
                'pos_profile_long': record['x'],
                'pos_profile_lat': record['y'],
                'speed_profile_long': record['speed'],
                'speed_profile_lat': record['speed_lat'],
                'width': record['width'],
                'length': record['length']
            }

    return fsm_ready_data



def update_to_max_speed(fsm_ready_data, freq=30):
    # Create a new dictionary copying all data
    updated_data = {frame: {vid: vdata.copy() for vid, vdata in vehicles.items()}
                    for frame, vehicles in fsm_ready_data.items()}

    # Iterate over each frame's data
    for frame, vehicles in fsm_ready_data.items():
        for vehicle_id, vehicle_data in vehicles.items():
            if vehicle_id % 2 == 0:  # Process only even vehicle IDs (representing our own vehicle)
                # Collect all speeds from this vehicle across frames
                speeds = [fsm_ready_data[f][vehicle_id]['speed_profile_long'] for f in fsm_ready_data if vehicle_id in fsm_ready_data[f]]
                # Find the maximum speed
                max_speed = max(speeds)

                # Update speed for all frames from the first appearance
                for f in sorted(fsm_ready_data.keys()):
                    if vehicle_id in updated_data[f]:
                        updated_data[f][vehicle_id]['speed_profile_long'] = max_speed
                        if f > min(fsm_ready_data.keys()):
                            previous_frame = f - 1
                            if previous_frame in updated_data and vehicle_id in updated_data[previous_frame]:
                                previous_position = updated_data[previous_frame][vehicle_id]['pos_profile_long']
                                updated_data[f][vehicle_id]['pos_profile_long'] = previous_position + max_speed * (1 / freq)

    return updated_data

# Assuming fsm_ready_data is already loaded and transformed




def FSM_check_safety(human_fsm_data, frame, ego_id, cutting_in_id, freq):
    # 获取特定帧和车辆的数据
    ego_veh_data = human_fsm_data[frame][ego_id]
    cutting_in_veh_data = human_fsm_data[frame][cutting_in_id]

    # 执行安全性检查
    if ego_veh_data['pos_profile_long'] > cutting_in_veh_data['pos_profile_long']:
        return True

    if abs(ego_veh_data['pos_profile_lat'] - cutting_in_veh_data['pos_profile_lat']) - \
       (ego_veh_data['width'] / 2 + cutting_in_veh_data['width'] / 2) > 0:
        cutin_speed = abs(cutting_in_veh_data['speed_profile_lat'])

        # 安全检查：无侧向速度时视为安全
        if cutin_speed == 0:
            return True

        # 计算头车时间差（横向和纵向）
        headway_lat = (abs(ego_veh_data['pos_profile_lat'] - cutting_in_veh_data['pos_profile_lat']) -
                       (ego_veh_data['width'] / 2 + cutting_in_veh_data['width'] / 2)) / cutin_speed
        headway_lon = (abs(ego_veh_data['pos_profile_long'] - cutting_in_veh_data['pos_profile_long']) +
                       (ego_veh_data['length'] / 2 + cutting_in_veh_data['length'] / 2)) / \
                      (ego_veh_data['speed_profile_long'] - cutting_in_veh_data['speed_profile_long'])

        if headway_lat > headway_lon + 0.1:
            return True

    # 计算上一帧数据的加速度
    previous_frame = frame - 1
    if previous_frame in human_fsm_data and ego_id in human_fsm_data[previous_frame]:
        previous_frame_data = human_fsm_data[previous_frame][ego_id]
        ar = (ego_veh_data['speed_profile_long'] - previous_frame_data['speed_profile_long']) * freq
    else:
        ar = 0  # 若无前一帧数据，假设加速度为0

    dist = abs(ego_veh_data['pos_profile_long'] - cutting_in_veh_data['pos_profile_long']) - \
           (ego_veh_data['length'] / 2 + cutting_in_veh_data['length'] / 2)

    # 调用CFS和PFS函数
    cfs = ff.CFS(dist, ego_veh_data['speed_profile_long'], cutting_in_veh_data['speed_profile_long'],
              FSM_rt, FSM_br_min, FSM_br_max, FSM_bl, ar)
    pfs = ff.PFS(dist, ego_veh_data['speed_profile_long'], cutting_in_veh_data['speed_profile_long'],
              FSM_rt, FSM_br_min, FSM_br_max, FSM_bl, FSM_margin_dist, FSM_margin_safe_dist)

    ego_veh_data['cfs'] = cfs
    ego_veh_data['pfs'] = pfs

    if cfs + pfs == 0:
        return True
    return False




def check_all_frames_for_safety(human_fsm_data, freq):

    # 初始化记录不安全帧的变量
    unsafe_frames = []

    # 遍历每一帧中的所有车辆数据
    for frame, vehicles in human_fsm_data.items():
        # 过滤出奇数ID的切入车和偶数ID的本车
        cutting_in_vehicles = {vid: vdata for vid, vdata in vehicles.items() if vid % 2 != 0}
        ego_vehicles = {vid: vdata for vid, vdata in vehicles.items() if vid % 2 == 0}

        # 确保每一帧都有至少一辆切入车和一辆本车
        for ego_id, ego_data in ego_vehicles.items():
            for cutting_in_id, cutting_in_data in cutting_in_vehicles.items():
                # 执行安全检查
                if not FSM_check_safety(human_fsm_data, frame, ego_id, cutting_in_id, freq):
                    unsafe_frames.append(frame)
                    # print(f"Unsafe condition detected at frame {frame} between vehicle {ego_id} and {cutting_in_id}")

    # 返回记录的不安全帧列表
    return unsafe_frames



def FSM_react(human_fsm_data, frame, ego_id, cutting_in_id, freq, FSM_rt_counter, prev_deceleration):
    # 设置基本参数
    FSM_rt = 0.75
    FSM_br_min = 4
    FSM_br_max = 6
    FSM_bl = 7
    FSM_ar = 2
    FSM_margin_dist = 2
    FSM_margin_safe_dist = 2
    FSM_max_deceleration = 0.774 * 9.81
    CC_min_jerk = 12.65

    # 从 human_fsm_data 获取当前车辆数据
    ego_veh_data = human_fsm_data[frame][ego_id]
    cutting_in_veh_data = human_fsm_data[frame][cutting_in_id]
    
    # 获取当前纵向速度，如果有更新后的速度，使用更新后的速度
    speed_log = ego_veh_data.get('updated_speed', ego_veh_data['speed_profile_long'])

    # 计算距离
    dist = abs(ego_veh_data['pos_profile_long'] - cutting_in_veh_data['pos_profile_long']) - \
           (ego_veh_data['length'] / 2 + cutting_in_veh_data['length'] / 2)

    # 计算加速度
    ar = 0
    previous_frame = frame - 1
    if previous_frame in human_fsm_data and ego_id in human_fsm_data[previous_frame]:
        previous_frame_data = human_fsm_data[previous_frame][ego_id]
        ar = (speed_log - previous_frame_data.get('updated_speed', previous_frame_data['speed_profile_long'])) * freq

    # 调用 CFS 和 PFS 函数
    cfs = ff.CFS(dist, speed_log, cutting_in_veh_data['speed_profile_long'], FSM_rt, FSM_br_min, FSM_br_max, FSM_bl, ar)
    pfs = ff.PFS(dist, speed_log, cutting_in_veh_data['speed_profile_long'], FSM_rt, FSM_br_min, FSM_br_max, FSM_bl, FSM_margin_dist, FSM_margin_safe_dist)

    # 更新 cfs 和 pfs 到数据
    ego_veh_data['cfs'] = cfs
    ego_veh_data['pfs'] = pfs

    # 检查反应时间计数器
    if FSM_rt_counter > 0:
        FSM_rt_counter -= 1 / freq
        return speed_log, prev_deceleration, FSM_rt_counter

    # 根据 cfs 和 pfs 计算加速度调整
    acc = cfs * (FSM_br_max - FSM_br_min) + FSM_br_min if cfs > 0 else pfs * FSM_br_min

    # 计算减速度
    deceleration = min(min(prev_deceleration + CC_min_jerk / freq, FSM_max_deceleration), acc)

    # 计算新的速度
    new_speed = max(speed_log - deceleration / freq, 0)

    # 将更新后的速度保存回数据结构，用于下一帧的计算
    ego_veh_data['updated_speed'] = new_speed

    return new_speed, deceleration, FSM_rt_counter


def process_frames(newdata, start_frame, end_frame, freq):
    
    FSM_rt_counter = 0.75
    deceleration = 0
    
    for frame in range(int(start_frame), int(end_frame) + 1):
        if frame in newdata:
            for ego_id, ego_data in newdata[frame].items():
                if int(ego_id) % 2 == 0:
                    cutting_in_id = ego_id - 1
                    speed_log =  newdata[frame][ego_id]['speed_profile_long']
                    new_speed, deceleration, FSM_rt_counter = FSM_react(newdata, frame, ego_id, cutting_in_id, freq, FSM_rt_counter, deceleration)
                    new_speed = max(speed_log - deceleration / freq, 0)
                    human_fsm_data[frame][ego_id]['speed_profile_long'] = new_speed
                    print(f"Frame {frame}, Vehicle {ego_id}: New Speed = {new_speed}, Deceleration = {deceleration}")

    return newdata  # 返回修改后的数据

# 假设 original_human_fsm_data 已经正确加载和准备





def collect_decelerations(human_fsm_data, start_frame, end_frame, freq):
    decelerations_by_frame = {}
    FSM_rt_counter = 0.75  # 初始化反应时间计数器
    deceleration = 0
    for frame in range(int(start_frame), int(end_frame) + 1):
        if frame in human_fsm_data:
            for ego_id, ego_data in human_fsm_data[frame].items():
                if int(ego_id) % 2 == 0:  # 偶数ID为本车
                    cutting_in_id = ego_id - 1  # 获取切入车辆ID
                    _, deceleration, FSM_rt_counter = FSM_react(human_fsm_data, frame, ego_id, cutting_in_id, freq, FSM_rt_counter, deceleration)
                    
                    # 将减速度存储在字典中
                    decelerations_by_frame[frame] = deceleration
                    print(f"Frame {frame}, Vehicle {ego_id}: Deceleration = {deceleration}")

    return decelerations_by_frame



def find_cutting_in_vehicle(vehicles, ego_id):
    for vid in vehicles:
        if vid != ego_id and vid % 2 != 0:  # 假设奇数ID为切入车
            return vid
    return None
def find_ego_vehicle(vehicles, ego_id):
    for vid in vehicles:
        if vid != ego_id and vid % 2 != 0:  # 假设奇数ID为切入车
            vid1 = vid + 1
            return vid1
    return None




# 载入原始数据

def calculate_speeds(fsm_ready_data, human_fsm_data, decelerations_data, start_frame, end_frame, freq):
    # 获取偶数 ID 车辆的最大速度作为初始速度
    max_speed = 0
    for frame_data in fsm_ready_data.values():
        for vehicle_id, vehicle_data in frame_data.items():
            if int(vehicle_id) % 2 == 0:  # 偶数ID为本车
                max_speed = max(max_speed, vehicle_data['speed_profile_long'])

    # 初始化速度字典
    speeds = {}
    speed_log = max_speed  # 设置初始速度

    # 从初始帧开始计算每一帧的新速度
    for frame in range(int(start_frame), int(end_frame) + 1):
        if frame in decelerations_data:
            deceleration = decelerations_data[frame]
            new_speed = max(speed_log - deceleration / freq, 0)
            speeds[frame] = {'speed': new_speed, 'deceleration': deceleration}
            speed_log = new_speed  # 更新速度以用于下一帧的计算

    # 打印每帧的速度和减速度
    # for frame, data in speeds.items():
    #     print(f"Frame {frame}: Speed = {data['speed']}, Deceleration = {data['deceleration']}")

    return speeds


def calculate_positions(speeds_data, human_fsm_data, unsafe_frames):
    # 获取初始位置 x0
    unsafe_frames = check_all_frames_for_safety(human_fsm_data, frequency)
    initial_frame = unsafe_frames[0]
    max_frame = max(speeds_data.keys())
    for frame_data in fsm_ready_data.values():
        for vehicle_id, vehicle_data in frame_data.items():
            if int(vehicle_id) % 2 == 0:  # 偶数ID为本车
                x0 = human_fsm_data[initial_frame][vehicle_id]['pos_profile_long']
    
    # 初始化位置字典，存储每帧的位置和速度
    positions = {initial_frame: {'position': x0, 'speed': speeds_data[initial_frame]['speed']}}

    # 从初始帧开始迭代计算每一帧的位置
    current_position = x0
    current_speed = speeds_data[initial_frame]['speed']
    for frame in sorted(speeds_data.keys()):
        if frame == initial_frame:
            continue
        if current_speed == 0:
            next_position = current_position
            next_speed = current_speed
        else:
        # 计算下一帧的位置
            delta_t = 1 / frequency  # 假设频率已经定义为 30Hz
            acceleration = speeds_data[frame]['deceleration']
            next_position = current_position + current_speed * delta_t - 0.5 * acceleration * (delta_t ** 2)
            if frame == max_frame:
                next_speed = current_speed
            else:
                next_frame = frame + 1
                next_speed = speeds_data[next_frame]['speed']
        
        # 更新当前位置和速度为下一帧的值
        current_position = next_position
        current_speed = speeds_data[frame]['speed']
        
        # 存储每帧的位置和速度
        positions[frame] = {'position': next_position, 'speed': next_speed}
    for frame, data in positions.items():
        print(f"Frame {frame}: POSITION = {data['position']}, SPEED = {data['speed']}")
    return positions













def update_human_fsm_data(human_fsm_data, positions):
    # 复制原始数据以避免直接修改输入字典
    updated_data = {frame: {vid: data.copy() for vid, data in vehicles.items()}
                    for frame, vehicles in human_fsm_data.items()}

    # 更新数据
    for frame, data in positions.items():
        for vehicle_id in updated_data[frame]:
            if int(vehicle_id) % 2 == 0:  # 只更新偶数ID的本车
                # 更新纵向位置和速度
                updated_data[frame][vehicle_id]['pos_profile_long'] = data['position']
                updated_data[frame][vehicle_id]['speed_profile_long'] = data['speed']

    # 打印更新后的数据
    print_updated_data(updated_data)

    return updated_data

def print_updated_data(updated_data):
    for frame in sorted(updated_data.keys()):
        print(f"Frame {frame}:")
        for vehicle_id, data in updated_data[frame].items():
            print(f" Vehicle ID {vehicle_id}: Position = {data['pos_profile_long']}, Speed = {data['speed_profile_long']}")






def print_fsm_data(fsm_data):
    # 遍历所有帧
    for frame in sorted(fsm_data.keys()):
        print(f"Frame {frame}:")
        vehicles = fsm_data[frame]
        # 遍历帧中的所有车辆
        for vehicle_id, data in vehicles.items():
            print(f"  Vehicle ID {vehicle_id}:")
            print(f"    Position (Longitudinal, Lateral): ({data['pos_profile_long']}, {data['pos_profile_lat']})")
            print(f"    Speed (Longitudinal, Lateral): ({data['speed_profile_long']}, {data['speed_profile_lat']})")
            print(f"    Dimensions (Width x Length): {data['width']} x {data['length']}")



def final_human_fsm_data(human_fsm_data, updated_data):
    """
    更新 human_fsm_data 字典，将 updated_data 中的速度和位置更新到 human_fsm_data 中相应的帧和偶数ID的车辆。

    参数:
    human_fsm_data: dict, 原始的车辆数据字典，按帧号组织。
    updated_data: dict, 包含需要更新的速度和位置信息的字典，也按帧号组织。

    返回:
    human_fsm_data: dict, 更新后的车辆数据字典。
    """
    # 遍历每一个帧
    for frame, vehicles in updated_data.items():
        # 检查此帧是否在原始数据中存在
        if frame in human_fsm_data:
            # 遍历需要更新的每一辆车的数据
            for vehicle_id, vehicle_data in vehicles.items():
                # 确保只更新偶数ID的车辆
                if int(vehicle_id) % 2 == 0:
                    # 更新速度和位置
                    human_fsm_data[frame][vehicle_id]['speed_profile_long'] = vehicle_data['speed_profile_long']
                    human_fsm_data[frame][vehicle_id]['pos_profile_long'] = vehicle_data['pos_profile_long']
    return human_fsm_data











file_path = '/home/dji/disk1/zhouhang/shuju/CUTIN11_40_15_0__4_20_fail_M3_tracks.csv'

FSM_rt = 0.75
FSM_rt_counter = FSM_rt
FSM_br_min = 4
FSM_br_max = 6
FSM_bl = 7
FSM_ar = 2
FSM_margin_dist = 2
FSM_margin_safe_dist = 2
FSM_max_deceleration = 0.774 * 9.81
frequency = 30
data_dict_by_id = load_csv_to_dict_by_id(file_path)
fsm_ready_data = transform_data_for_fsm(data_dict_by_id)

# 更新数据以达到最大速度或其他逻辑
human_fsm_data = update_to_max_speed(fsm_ready_data, freq=30)
human_final_data = update_to_max_speed(fsm_ready_data, freq=30)

unsafe_frames = check_all_frames_for_safety(human_fsm_data, frequency)



start_frame = unsafe_frames[0]
frequency = 30  # 更新频率，例如30Hz



freq = 30
end_frame = max(human_fsm_data.keys())

decelerations_data = collect_decelerations(human_fsm_data, start_frame, end_frame, freq)




speeds_data = calculate_speeds(fsm_ready_data, human_fsm_data, decelerations_data, start_frame, end_frame, freq)


positions = calculate_positions(speeds_data, human_fsm_data, unsafe_frames)


updated_data = update_human_fsm_data(human_fsm_data, positions)

final_data = final_human_fsm_data(human_final_data, updated_data)

print_fsm_data(final_data)
